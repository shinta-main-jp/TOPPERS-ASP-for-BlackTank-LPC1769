
		TOPPERS/ASPカーネル
		機能拡張・チューニングガイド

		対応バージョン: Release 1.6.0
		最終更新: 2010年2月9日

このドキュメントは，TOPPERS/ASPカーネルを，機能拡張・チューニングするた
めの方法（またはヒント）を説明するものである．

----------------------------------------------------------------------
 TOPPERS/ASP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Advanced Standard Profile Kernel

 Copyright (C) 2005-2010 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 $Id: extension.txt 1862 2010-07-25 11:49:51Z ertl-hiro $
----------------------------------------------------------------------

○目次

・エラーチェックの省略
・タイムティックの周期の変更
・特殊目的のレジスタの扱い
・ミューテックス機能拡張パッケージ
・オーバランハンドラ機能拡張パッケージ
・タスク優先度拡張パッケージ
・CPU例外ハンドラの直接呼出し


○エラーチェックの省略

サービスコールのオーバヘッドを削減するために，静的なエラーのチェックを
省略する場合がある．ASPカーネルにおいては，静的なエラーのチェックはすべ
てCHECKマクロを用いて行っているため，kernel/check.h中のCHECKマクロを編
集することで，静的なエラーのチェックを省略することができる．

例えば，タスクIDのチェックを省略したい場合には，CHECK_TSKIDマクロと
CHECK_TSKID_SELFマクロを，次のように修正すればよい．

#define CHECK_TSKID(tskid)			((void)(tskid))
#define CHECK_TSKID_SELF(tskid)		((void)(tskid))

これらのマクロの定義を空にする方法もあるが，パラメータに副作用のある式
が書かれている可能性を考えると（副作用のある式は書くべきではないが，書
かれているコードが入ってくる可能性が全くないとは言えない），上の定義の
方が安全である．副作用のない式であれば，最適化によって削除することがで
きるため，実行時効率には影響がないと期待できる．ただし，最適化によって
削除されない場合には，副作用のある式が書かれていないことを確認した上で，
マクロの定義を空にしてもよい．


○タイムティックの周期の変更

ASPカーネルでは，カーネルへタイムティックを供給する周期は1ミリ秒が標準
となっているが，低速なプロセッサでは1ミリ秒毎に割込みを処理するオーバヘッ
ドが問題になる場合がある．そこで，アプリケーションが必要とする時間精度
が粗い場合には，タイムティックの周期を長くすることで，プロセッサの処理
負荷を低減する方法がある．

タイムティックの周期の与え方はターゲット依存であるため，これが変更でき
るかどうかは，ターゲット依存部のタイマドライバの実装を調べる必要がある．
標準的には，target_kernel.h（またはそこからインクルードされるファイル）
中に定義されているTIC_NUMEとTIC_DENOを書き換えることで，変更できるよう
に実装されている．


○特殊目的のレジスタの扱い

FPUレジスタやDSPレジスタなどの特殊目的のレジスタ（以下，特殊レジスタ）
を持つプロセッサでは，レジスタの扱いについて大きく次の3つの方法が考えら
れる．

(1) 特殊レジスタをタスクのコンテキストに含めない

1つのタスクのみが特殊レジスタを使用する場合には，特殊レジスタをタスクの
コンテキストに含める必要がなく，カーネルで管理する必要がない．

(2) 特殊レジスタをタスクのコンテキストに含める

複数のタスクが特殊レジスタを使用する場合には，特殊レジスタをタスクのコ
ンテキストに含める方法が最も単純である．そのためには，タスクディスパッ
チャと割込みハンドラ/CPU例外ハンドラの出入口で，特殊レジスタを保存/復帰
するコードを追加する必要がある．実際の保存/復帰場所は，スクラッチレジス
タとそれ以外のレジスタで異なるため，注意が必要である．

(3) 特殊レジスタをコンテキストに含めるかどうかをタスク毎に指定する

特殊レジスタを使用するタスクと使用しないタスクがある場合で，すべてのタ
スクのコンテキストに特殊レジスタを含める方法ではオーバヘッドが問題にな
る場合には，特殊レジスタをコンテキストに含めるかどうかをタスク毎に指定
する方法が有力である．これを実現する方法は次の通りである．

まず，特殊レジスタをコンテキストに含めるかどうかを指定するタスク属性を
設ける．例えば，FPUレジスタであれば，タスク属性にTA_FPUを設ける．タスク
ディスパッチャでは，タスク属性を見て，その属性が設定されていれば特殊レ
ジスタを保存/復帰する．

ハードウェア的に特殊レジスタがディスエーブルできる場合には，その属性が
設定されていないタスクに切り換える時に特殊レジスタをディスエーブルする
と，誤って特殊レジスタを使った場合を検出できる．

さらに，割込みハンドラ（ISR，周期ハンドラ，アラームハンドラを含む）や
CPU例外ハンドラで特殊レジスタを使用する場合には，これらの処理単位にも
特殊レジスタを使用するかどうかの属性を設ける方法が考えられる．

ここで，タスク（または他の処理単位）が特殊レジスタを使用するかどうかは，
コンパイラやライブラリに依存する場合があるため，注意が必要である．例え
ば，浮動小数点演算を含まないプログラムであっても，コンパイラがその方が
性能が高いと判断すれば，浮動小数点命令を生成する場合がある．


○ミューテックス機能拡張パッケージ

ASPカーネルに，ミューテックス機能を追加するための拡張パッケージを用意し
ている．ただし，優先度逆転を制御するための仕組みとして，優先度上限ミュー
テックス（TA_CEILING属性のミューテックス）のみをサポートし，優先度継承
ミューテックス（TA_INHERIT属性のミューテックス）はサポートしていない．

拡張パッケージは，extension/mutexディレクトリに置いてある．拡張パッケー
ジを使用する場合には，UNIXであれば，ASPカーネルのソースファイルのトップ
ディレクトリで，

	% cp -r extension/mutex/* .

を実行する．この時，元の（拡張前の）ソースファイルは上書きされてしまう
ため，拡張しないカーネルも使用したい場合には，別のディレクトリにソース
ファイルを展開して，上のコマンドを実行すること．また，複数の拡張パッケー
ジを使う場合には，それらが衝突する可能性があるので，注意が必要である．

ミューテックス機能拡張パッケージでは，TOPPERS_SUPPORT_MUTEXがkernel.h中
で定義されているので，これを用いてミューテックス機能を使用できるかどう
かを判別することができる．


○オーバランハンドラ機能拡張パッケージ

ASPカーネルに，オーバランハンドラ機能を追加するための拡張パッケージを用
意している．ただし，この拡張パッケージを使うためには，ターゲット依存部
が対応している必要がある．

拡張パッケージは，extension/ovrhdrディレクトリに置いてある．拡張パッケー
ジの使用方法は，ミューテックス機能と同様である．

オーバランハンドラ機能拡張パッケージで，ターゲット依存部が拡張パッケー
ジに対応している場合には，TOPPERS_SUPPORT_OVRHDRがkernel.h中で定義され
るので，これを用いてオーバランタイマ機能が使用できるかどうかを判別する
ことができる．


○タスク優先度拡張パッケージ

タスク優先度を最大256段階に拡張するための拡張パッケージを用意している．
この拡張パッケージは，タスク優先度に加えて，データ優先度，メッセージ優
先度，割込みサービスルーチン優先度も256段階に拡張する．

拡張パッケージは，extension/pri_levelディレクトリに置いてある．拡張パッ
ケージの使用方法は，ミューテックス機能と同様である．

タスク優先度拡張パッケージでは，TOPPERS_SUPPORT_PRI_LEVELがkernel.h中で
定義されているので，これを用いてタスク優先度の範囲が拡張されているかど
うかを判別することができる．


○CPU例外ハンドラの直接呼出し

CPU例外ハンドラの出入口処理は，CPU例外が発生しないように実装しなければ
ならないが，これが防げないターゲットにおいては，CPU例外ハンドラの出入口
処理を経由せずに，アプリケーションが用意したCPU例外ハンドラを直接実行す
る方法を用意するのが望ましい．これを，CPU例外ハンドラの直接呼出しと呼ぶ．

ここでは，ハードウェアでベクタテーブルを持つプロセッサにおいて，ターゲッ
ト依存部のみの修正により，CPU例外ハンドラの直接呼出しの機能を追加する方
法について説明する．

●TA_DIRECT属性の導入

CPU例外ハンドラの直接呼出しを指定するために，CPU例外ハンドラ属性に，
TA_DIRECT属性を導入する．

●ターゲット依存部の修正箇所

TA_DIRECTの値を，target_kernel.h（または，そこからインクルードされるファ
イル）で定義し，その値をコンフィギュレータが取り出せるように，
target_def.csv（または，それに代わるファイル）に次の行を追加する．

TA_DIRECT,TA_DIRECT

次に，target.tf（または，そこからインクルードされるファイル）で，
TARGET_INHATRに設定される値に，TA_DIRECTを追加する．例えば，TARGET_INHATR
にTA_NONKERNELのみが設定されていた場合には，次のように修正する．

$TARGET_INHATR = TA_NONKERNEL | TA_DIRECT$

次に，OMIT_INITILIZE_EXCEPTIONを用いて，CPU例外ハンドラの出入口処理を生
成するための記述とCPU例外ハンドラ初期化ブロックの標準の定義が生成される
のを抑止し，それによって抑止される部分をtarget.tfにコピーした上で，以下
の修正を加える．

CPU例外ハンドラの出入口処理を生成するための記述（EXCHDR_ENTRYのリスト）
を生成する部分は，次のように修正する．

$FOREACH excno EXC.ORDER_LIST$
	$IF (EXC.EXCATR[excno] & TA_DIRECT) == 0$
		EXCHDR_ENTRY($EXC.EXCNO[excno]$, $+EXC.EXCNO[excno]$, $EXC.EXCHDR[excno]$)$NL$
	$END$
$END$

また，CPU例外ハンドラ初期化ブロックの定義を生成する部分は，次のように修
正する．

const EXCINIB _kernel_excinib_table[TNUM_EXCNO] = {$NL$
$JOINEACH excno EXC.ORDER_LIST ",\n"$
	$IF (EXC.EXCATR[excno] & TA_DIRECT) == 0$
		$TAB${ ($EXC.EXCNO[excno]$), ($EXC.EXCATR[excno]$), (FP)(EXC_ENTRY($EXC.EXCNO[excno]$, $EXC.EXCHDR[excno]$)) }
	$ELSE$
		$TAB${ ($EXC.EXCNO[excno]$), ($EXC.EXCATR[excno]$), (FP)($EXC.EXCHDR[excno]$) }
	$END$
$END$$NL$
};$NL$

以上
