/**
 * @file doxygen_firmware.c
 * @author Shinichiro Nakamura
 * @brief Doxygen用のファイル。ファームウェアに関するトピックを記述してある。
 * @details
 *
 * @page firmware ファームウェアに関するトピック
 *
 * ファームウェアに関する既知の問題点については @ref problems_firmware をご覧下さい。
 *
 * @section task_structure_design タスク設計
 *
 * @subsection task_userinput ユーザインプットタスク(task_userinput)
 *
 *  ユーザインプットタスクは４系統のユーザ入力の変化を観察する
 *  タスクです。
 *  変化があればデータキューを介してシステムコントロールタスクに
 *  通知されます。
 *
 * @subsection task_menu メニュータスク(task_menu)
 *
 *  メニュータスクはユーザにシステムのサービスを提示し、
 *  ユーザからの要求をシステムに伝達する役目を果たします。
 *
 *  ユーザは各タスクから次のマクロのみで指示することができます。
 *
 *  @code
 *  USERMSG(device, value);
 *  @endcode
 *
 *  - deviceは以下から選択できます。
 *    - スイッチ: SW0, SW1, SW2, SW3
 *    - ボリューム: VOL0, VOL1, VOL2, VOL3
 *    .
 *  .
 *
 *  - Typeはビットマッピングです。
 *    - 長押し状態フラグ：SW_LONG_PUSH
 *    .
 *  .
 *
 *  このタスクへの指示はデータキューを介して行われます。
 *  データキュー内部データ構造は以下のようになっています。
 *
 *  <pre>
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+------------------+
 *  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0| Description      |
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+------------------+
 *  |                 |<-          [9:0]          ->| Value            |
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+------------------+
 *  |           |11:10|                             | Type             |
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+------------------+
 *  |<-[15:12]->|                                   | Device           |
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+------------------+
 *  </pre>
 *
 * @subsection task_led LEDタスク(task_led)
 *
 *  LEDタスクはLEDの点灯を制御するタスクです。
 *
 *  点灯は各タスクから次のマクロのみで指示することができます。
 *
 *  @code
 *  LEDMSG(target, control);
 *  @endcode
 *
 *  - targetは以下から選択できます。
 *    - デバッグ用LED: DBLED0, DBLED1, DBLED2, DBLED3
 *    - スイッチ用LED: SWLED0, SWLED1, SWLED2, SWLED3
 *    .
 *  .
 *
 *  - controlは以下から選択できます。
 *    - LED点灯：LEDON
 *    - LED消灯：LEDOFF
 *    .
 *  .
 *
 *  このタスクへの指示はデータキューを介して行われます。
 *  データキュー内部データ構造は以下のようになっています。
 *
 *  <pre>
 *  +---+---+---+---+---+---+---+---+-------------+
 *  | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | Description |
 *  +---+---+---+---+---+---+---+---+-------------+
 *  |               |<-   [3:0]   ->| Target      |
 *  +---+---+---+---+---+---+---+---+-------------+
 *  |   | x   x   x |               | Reserved    |
 *  +---+---+---+---+---+---+---+---+-------------+
 *  |[7]|                           | Control     |
 *  +---+---+---+---+---+---+---+---+-------------+
 *  </pre>
 *
 * @subsection task_display ディスプレイタスク(task_display)
 *  ディスプレイタスクは有機ELディスプレイを制御するタスクです。
 *
 *  ディスプレイの制御は以下のマクロを使って行うことができます。
 *
 *  @code
 *  DISP_CLEAR(R, G, B);
 *  DISP_LINE(X1, Y1, X2, Y2, R, G, B);
 *  DISP_BOX(X1, Y1, X2, Y2, R, G, B);
 *  DISP_FILLBOX(X1, Y1, X2, Y2, R1, G1, B1, R2, G2, B2);
 *  DISP_TEXT(X, Y, R, G, B, "TEXT");
 *  DISP_BMPFILE("0:FILENAME");
 *  DISP_AUDIO_LEVELMETER(L, R);
 *  @endcode
 *
 *  タスク間はメールボックスでやりとりされます。
 *  マクロはこれを隠蔽した実装としました。
 *  メールボックスで陥りがちな同期問題を未然に防ぐ対策として
 *  メモリプール管理機能を使ってデータ領域に対するアクセスを
 *  管理しています。
 *
 *  今回の実装では受信側が処理を完了するまで送信側が次の処理に
 *  遷移しない実装にしてあります。
 *  今回のタスク設計ではメニュータスクがブロックの対象となります。
 *
 * @subsection task_ntshell ナチュラルタイニーシェルタスク(task_ntshell)
 *  システムをコンソールから制御することのできるインターフェース
 *  タスクです。
 *
 * @subsection task_audio オーディオタスク(task_audio)
 *  オーディオを処理するためのタスクです。
 *
 *  このタスクにはパラメータを指定するためのマクロがあります。
 *
 *  @code
 *  AUDIO_PARAM(TARGET,VALUE);
 *  @endcode
 *
 *  - TARGETとVALUEは以下から選択します。
 *    - TARGET: VAR0, VAR1, VAR2, VAR3
 *    - VALUE : The value of the target.
 *    .
 *  .
 *
 *  <pre>
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+------------------+
 *  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0| Description      |
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+------------------+
 *  |           |<-            [11:0]             ->| Value            |
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+------------------+
 *  |<-[15:12]->|                                   | Target           |
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+------------------+
 *  </pre>
 *
 *  VAR0, VAR1, VAR2, VAR3の各値をどのように使うのかは実装される
 *  オーディオエフェクトに依存します。
 *  詳しくはaudio_effect.cを御参照下さい。
 *
 * @section application_examples アプリケーション例
 *
 * - オーディオエフェクタ
 * - メトロノーム
 * - 多機能時計
 * - ピンボールゲーム
 *
 * @section task_priority プライオリティ
 *
 * タスクプライオリティに関しては以下のように定めた。
 * 一般にRTOSのプライオリティはサーバ＞クライアントとなる。
 * これに層別の視点を加えてプライオリティを決定した。
 *

 10: リアルタイム・タスク
    task_audio
 11: サーバ・タスク
    task_display
    task_led
 12: クライアント・タスク
    task_menu
    task_userinput
 13: イニシャライザ
    task_audio_init
    task_splash
 14: デバッガ
    task_ntshell

 *
 * @section sec_audio_effect_refactoring オーディオ処理の効率改善。
 *
 * ここではオーディオ処理の効率改善について記す。
 *
 * @subsection sec_audio_effect_refactoring1 オリジナルの設計
 *
 * オリジナルの実装では以下のような処理となっていた。
 *
 * - DMA転送されたオーディオバッファサイズ分のデータがrxbufに入っている。
 * - 並び替えながらrxbufからaudio_data.inputBufferにコピーする。
 * - オーディオ処理を実行する。
 *   -- ここでは処理に応じてaudio_data.inputBufferからaudio_data.outputBufferへのコピーが発生する。
 *   .
 * - 並び替えながらaudio_data.outputBufferからtxbufにコピーする。
 * .
 *
 * 図を用いて整理すると以下のようになる。
 *
 * <pre>
 * +-----+      +-----------+      +------------+      +-----+
 * |rxbuf|  ->  |inputBuffer|  ->  |outputBuffer|  ->  |txbuf|
 * +-----+      +-----------+      +------------+      +-----+
 * </pre>
 *
 * 要するに主記憶上におけるメモリコピーが少なくとも３回発生している。
 * 通常、性能という観点で見た場合、メモリコピーは性能劣化の主要な要因の
 * ひとつとなる。
 *
 * そこで、今回は上記処理の効率改善を行う。
 *
 * まず初めに、最小限の処理について考えてみる。
 * 入力をそのまま出力に伝達する場合、単なるメモリコピーで良い。
 *
 * <pre>
 * +-----+      +-----+
 * |rxbuf|  ->  |txbuf|
 * +-----+      +-----+
 * </pre>
 *
 * オリジナルの実装ではコーデックのデータ形式に伴い少し工夫がしてある。
 * この処理を順次見ていくことにする。
 *
 * まず初めに入力されたデータを内部で扱いやすい形式にメモリコピーする。
 * これはrxbufからinputBufferへのコピーである。
 *
 * <pre>
 * +--------------------------+
 * |+-----+      +-----------+|      +------------+      +-----+
 * ||rxbuf|  ->  |inputBuffer||  ->  |outputBuffer|  ->  |txbuf|
 * |+-----+      +-----------+|      +------------+      +-----+
 * +--------------------------+
 * </pre>
 *
 * 次にオーディオの処理を実行する。
 * これはinputBufferからoutputBufferへのコピーである。
 * オーディオの処理を実装する過程で、ここに様々な演算が入ることになる。
 *
 * <pre>
 *              +---------------------------------+
 * +-----+      |+-----------+      +------------+|      +-----+
 * |rxbuf|  ->  ||inputBuffer|  ->  |outputBuffer||  ->  |txbuf|
 * +-----+      |+-----------+      +------------+|      +-----+
 *              +---------------------------------+
 * </pre>
 *
 * 最後に結果を出力バッファに書き込む。
 * outputBufferからtxbufへのコピーである。
 * これはオーディオバッファの内容を、都合の良い形式に前段で並び替えた結果発生する作業である。
 *
 * <pre>
 *                                 +---------------------------+
 * +-----+      +-----------+      |+------------+      +-----+|
 * |rxbuf|  ->  |inputBuffer|  ->  ||outputBuffer|  ->  |txbuf||
 * +-----+      +-----------+      |+------------+      +-----+|
 *                                 +---------------------------+
 * </pre>
 *
 * まとめると以下のようになる。
 * - コーデックから得られたデータ形式は扱いにくいので並び替える。
 * - 並び替えは主記憶上でMCUが実行する。
 * - 並び替えたデータは、コーデックがそのまま扱えないので再変換する。
 * .
 *
 * @subsection sec_audio_effect_refactoring2 オーディオ処理の効率改善
 *
 * 先にオリジナルの設計について述べた。
 * ここでは実際にオーディオ処理の効率改善について述べる。
 *
 * 基本的な思想は以下の通りである。
 * - 主記憶上におけるメモリコピーは性能に対して致命傷である。
 * - より多くの処理を実現するためにはメモリコピーを排除すれば良い。
 * - メモリコピーを行なっている主な理由はデータ形式変換である。
 * - データ形式変換が不要となるような枠組みを用意すればデータ形式変換が不要となるはずである。
 * .
 *
 * 要するに「データ形式変換」を実現しながらも、「メモリコピー」を発生させないという矛盾を解決すれば良い事になる。
 * オリジナルの実装ではオーディオ処理関数に渡るデータ形式が重要であった。
 * この点は改善案でも特に変わるものではない。
 * オリジナルと異なるのはその実現手法である。
 *
 * 通常、オーディオ処理では特定サンプルに対して、時間軸方向前後のデータも用いてフィルタリングを行なう。
 * オリジナルの実装はDMA転送されたデータを１つの塊とみなし、オーディオ処理関数に渡す形をとっている。
 * 提案手法ではオーディオ処理関数に渡ってくるデータは１サンプル分のみである。しかしながら、主記憶上におけるメモリコピーは一切発生しない。
 * このため、高速でMCUの演算能力をフルにオーディオ処理に割り当てる事が可能となる。
 *
 * ここで問題となるのが時間軸方向のフィルタリング処理時である。
 */

